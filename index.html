<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Simple Grid View by ggu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Simple Grid View</h1>
      <h2 class="project-tagline">a simple iPad and iPhone grid view</h2>
      <a href="https://github.com/ggu/SimpleGridView" class="btn">View on GitHub</a>
      <a href="https://github.com/ggu/SimpleGridView/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/ggu/SimpleGridView/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="simple-grid-view" class="anchor" href="#simple-grid-view" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simple Grid View</h1>

<p>A grid view (the kind of symmetrical grid you'd use for a pathfinding application or a game of some sort) based around UIKit. I am currently working on a visual pathfinder in Swift with this as a base, separate from any sort of pathfinding AI.</p>

<h1>
<a id="the-code" class="anchor" href="#the-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Code</h1>

<ul>
<li><p>TileView is a UIView subclass that stores a Tile and handles active and inactive state changes (the defaults I have set for this app, but you might have various states like inactive, target, obstacle, start etc..).</p></li>
<li><p>GridView is another UIView subclass that handles a 2D list of TileView and manages the touches. Touches are currently handled here (e.g. you tap or swipe over TileViews and modify their state). I am not sure if I would be able to handle the touches in TileView, which would be ideal but touchesmoved is currently stopping me from doing that as touchesmoved holds onto the original view, and would not be called on other TileViews. If your app does not depend on swipes over the grid, then I might move the touches functionality to the TileView to obstract more away from GridView. traverseGrid is the core method you will use to update tile states for some condition (e.g. when swiping, does tile frame contain swipe location?) or for applying a state to the entire grid, otherwise accessing the tile you need directly with grid[x][y] makes the most sense.</p></li>
<li><p>Tile is a class that is meant to hold the properties that your application's logic would want to track. If you were using this for a game, a tile might have a property for its height on your map (e.g. forests are of height 1, mountains are of height 10 etc) to tie into your game's formula for unit movement. Or if you were strictly pathfinding, you might add a property just for risk. As far as a Tile's Type goes, this is for tracking the state of your tile. Maybe it could be an obstacle, or a dynamic obstacle with some risk. Or even your goal tile. For now, tiles are strictly represented as active or inactive for the purpose of this demonstration as every app that would build on this would have its own system for managing what kind of state users' touches would set.</p></li>
<li><p>Constants.swift houses some of the main values you might want to edit (like tile dimensions, tile margins, colors, possible tile states etc). One very important enum is Condition. You will pass in a Condition type into traverseGrid as well as a value that can be of any type and these together will allow you to use traverseGrid flexibly to do a variety of things (maybe you want to check if the tile has risk &lt; 10 for your pathfinding, so you could create a Condition case for risk and then you could add another switch case within traverseGrid so that if your Condition is risk, you could pass in a value for risk and check the tile's risk against the unwrapped optional risk value passed into traverseGrid.</p></li>
</ul>

<h1>
<a id="simple-demo" class="anchor" href="#simple-demo" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simple demo</h1>

<p>The demo is not really representative of what this is meant to be used for, but it's there so you can see at a glance what this looks like with the default constants.</p>

<p><img src="https://github.com/ggu/grid-view-/blob/master/demo1.gif?raw=true" alt="Image of Demo1"></p>

<h1>
<a id="to-do" class="anchor" href="#to-do" aria-hidden="true"><span class="octicon octicon-link"></span></a>To Do</h1>

<ul>
<li><p>support for panning around a grid larger than the screen </p></li>
<li><p>make a version to work specifically with Sprite Kit for non-UIKit games (like a top-down strategy game or role-playing game that would need a layer like this).</p></li>
</ul>

<p>personal website: <a href="http://gabrieluribe.me">gabrieluribe.me</a></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/ggu/SimpleGridView">Simple Grid View</a> is maintained by <a href="https://github.com/ggu">ggu</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
